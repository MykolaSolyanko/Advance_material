# Topics
1. Smart pointers
2. std::unique_ptr
3. std::shared_ptr
4. std::unique_ptr vs std::shared_ptr. Move vs Copy
5. make_* как способ избежать утечки ресурсов при передачи умных указателей как аргументы функции. Возможен разный порядок вычисления аргументов.
6. Control block в std::shared_ptr. Зачем он нужен, какие он решает задачи, и возможные подводные камни при выделении ресурса при помощи std::make_shared.
7. Производительность std::unique_ptr и std::shared_ptr.
8. std::weak_ptr. Его применение, его влияние на блок управление в std::shared_ptr
9. Выделение динамического массива с помощью std::unique_ptr и std::shared_ptr. Специализация.
10. Зачем пользовательские deleter объекты как аргументы std::unique_ptr и std::shared_ptr. decltype как вывод сигнатуры функции.
11. Исключительные ситуации. Их важное применение.
12. Исключительные ситуации vs код возрата ошибки. Когда полезно применять код возрата ошибки.
13. Класс std::exception. Виртуальный метод what.
14. Блоки `try catch`.
15. `throw` как генерация исключения.
16. Получение объекта исключения по константной ссылке. Почему?).
17. Порядок написания блоков `catch`.
18. Блок `catch(...)` как способ обработать все исключение.
19. Что такое раскрутка стека при генерации исключения. Что будет если при генерации исключения не будет найден подходящий блок `catch`.
20. Что такое инвариантность при генерации исключения в конструкторе.
21. Правило написания инвариантности при написании например `operator =`.
22. Важность исключения при написании арифметического класса в перегруженных функциях `operator += -= *= /=` и т.д.
23. Smart pointers как способ избежать утечки ресурсов при генерации исключения.
24. **Исключение не должно покидать Деструктор**
25. Ключевое слово noexcept. Все деструкторы по умолчанию как noexcept.
26. `noexcept(expression)`
27. Оптимизация при написании функций как noexcept. Важность написания перемещающего конструктора как noexcept, на примере std::vector. Почему std::vector выбирает при реалокации копирующее поведение как дефолтное, вместо перемещающей семантики(правило инвариантности).
28. Компиляция кода с флагом `-fno-exceptions`, возможные опастности.
29. `new(std::nothrow)` как способ использования оператора `new` который не кидает исключения.
 